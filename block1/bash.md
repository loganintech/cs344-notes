## Special Chars
```
$ - Process ID
? - Return Val of previous command or script
# - Number of args
1 - first arg
2 - second arg
FOO(number) - FOO arg
```

## For Loop
```sh
for i in list of items or an array
do
    commands
done
```

## While Loop

```sh
while booltest $i -ne 2
do
    printf "I = $i, not stopping yet \n"
    i=$(expr $i + 1)
done
printf "Stopping, i = $i\n"
```

Output of while loop
```
i = 0, not stopping yet
i = 1, not stopping yet
Stopping, i = 2
```

* Some operators (like =) and commands require strings or numbers to operate on, not other commands. We can calculate these values with subshells. Use "$(commands)" to start subshells (POSIX compatible). Methods eval that expression and grab results from stdout.

## Ex:
```sh
$(expr 1 + $some_var)
```
* Double parenthesis construct does arithmetic expansion and evaluation directly, no expr needed. There must be a space between operators and after `((` and before `))`
```sh
i=$(( 1 + $some_var ))
$(( i++ )) # Don't need dollar sign here
```
Use the `trap` command to catch signals (like SIGINT generated by hitting CTRL+C) and clean up the mess

* Usage:
  * trap <code to run> list of signals

```sh
#!/bin/bash

TMP="someCoolFilename$$"
trap "rm -rf $TMP; echo 'CTRL+C' received, exiting.'; exit 1" INT HUP TERM
echo "A mega fek tun of text" > $TMP
while [ 1 -ne 2 ]
do
echo "Never ending story (loop)"
done
```
